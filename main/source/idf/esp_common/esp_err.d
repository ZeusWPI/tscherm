module idf.esp_common.esp_err;

import idf.sdkconfig;

@safe nothrow @nogc:

bool unlikely(bool res) => res;

alias esp_err_t = int;

enum esp_err_t ESP_OK = 0; /// esp_err_t value indicating success (no error)
enum esp_err_t ESP_FAIL = -1; /// Generic esp_err_t code indicating failure

enum esp_err_t ESP_ERR_NO_MEM = 0x101; /// Out of memory
enum esp_err_t ESP_ERR_INVALID_ARG = 0x102; /// Invalid argument
enum esp_err_t ESP_ERR_INVALID_STATE = 0x103; /// Invalid state
enum esp_err_t ESP_ERR_INVALID_SIZE = 0x104; /// Invalid size
enum esp_err_t ESP_ERR_NOT_FOUND = 0x105; /// Requested resource not found
enum esp_err_t ESP_ERR_NOT_SUPPORTED = 0x106; /// Operation or feature not supported
enum esp_err_t ESP_ERR_TIMEOUT = 0x107; /// Operation timed out
enum esp_err_t ESP_ERR_INVALID_RESPONSE = 0x108; /// Received response was invalid
enum esp_err_t ESP_ERR_INVALID_CRC = 0x109; /// CRC or checksum was invalid
enum esp_err_t ESP_ERR_INVALID_VERSION = 0x10A; /// Version was invalid
enum esp_err_t ESP_ERR_INVALID_MAC = 0x10B; /// MAC address was invalid
enum esp_err_t ESP_ERR_NOT_FINISHED = 0x10C; /// Operation has not fully completed
enum esp_err_t ESP_ERR_NOT_ALLOWED = 0x10D; /// Operation is not allowed

enum esp_err_t ESP_ERR_WIFI_BASE = 0x3000; /// Starting number of WiFi error codes
enum esp_err_t ESP_ERR_MESH_BASE = 0x4000; /// Starting number of MESH error codes
enum esp_err_t ESP_ERR_FLASH_BASE = 0x6000; /// Starting number of flash error codes
enum esp_err_t ESP_ERR_HW_CRYPTO_BASE = 0xc000; /// Starting number of HW cryptography module error codes
enum esp_err_t ESP_ERR_MEMPROT_BASE = 0xd000; /// Starting number of Memory Protection API error codes

/**
 * Returns string for esp_err_t error codes.
 *
 * This function finds the error code in a pre-generated lookup-table and
 * returns its string representation.
 *
 * The function is generated by the Python script
 * tools/gen_esp_err_to_name.py which should be run each time an esp_err_t
 * error is modified, created or removed from the IDF project.
 *
 * Params:
 *   code = error code
 * Returns: error message
 */
extern (C)
const(char)* esp_err_to_name(esp_err_t code);

/**
 * Returns string for esp_err_t and system error codes.
 *
 * This function finds the error code in a pre-generated lookup-table of
 * esp_err_t errors and returns its string representation. If the error code
 * is not found then it is attempted to be found among system errors.
 *
 * The function is generated by the Python script
 * tools/gen_esp_err_to_name.py which should be run each time an esp_err_t
 * error is modified, created or removed from the IDF project.
 *
 * Params:
 *   code = error code
 *   buf = buffer where the error message should be written
 *   buflen = Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte).
 * Returns: `buf` containing the string error message
 */
extern (C)
const(char)* esp_err_to_name_r(esp_err_t code, char* buf, size_t buflen);

private extern (C)
noreturn _esp_error_check_failed(
    esp_err_t err,
    const char* file,
    int line,
    const char* func,
    const char* expr
);

private extern (C)
void _esp_error_check_failed_without_abort(
    esp_err_t err,
    const char* file,
    int line,
    const char* func,
    const char* expr
);

/**
 * Macro which can be used to check the error code,
 * and terminate the program in case the code is not ESP_OK.
 * Prints the error code, error location, and the failed statement to serial output.
 *
 * Disabled if assertions are disabled.
 */
@trusted
void ESP_ERROR_CHECK(
    string msg = "",
    string file = __FILE__,
    size_t line = __LINE__,
    string func = __FUNCTION__,
)(
    esp_err_t err,
)
{
    version (assert)
        if (unlikely(err != ESP_OK))
        {
            static if (is(typeof(CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT)))
                abort;
            else
                _esp_error_check_failed(err, file.ptr, line, func.ptr, msg.ptr);
        }
}

/**
 * Macro which can be used to check the error code. Prints the error code, error location, and the failed statement to
 * serial output.
 * In comparison with ESP_ERROR_CHECK(), this prints the same error message but isn't terminating the program.
 */
void ESP_ERROR_CHECK_WITHOUT_ABORT(
    string msg = "",
    string file = __FILE__,
    size_t line = __LINE__,
    string func = __FUNCTION__,
)(
    esp_err_t err,
)
{
    static if (!is(typeof(CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT)))
        version (assert)
            if (unlikely(err != ESP_OK))
                _esp_error_check_failed_without_abort(err, file.ptr, line.ptr, func.ptr, msg.ptr);
}
